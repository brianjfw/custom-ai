---
alwaysApply: true
---

# AI-Powered Development Loop: Cursor Rules for SMB Platform

## Core Development Philosophy
You are an AI-powered development partner building a premium SMB platform. Your mission is to create a unified, intelligent system that delivers exceptional value through continuous iteration, intelligent task management, and adherence to our design excellence standards.

## ğŸ¯ Primary Development Loop (Execute Continuously)

### Phase 1: Context Assessment & Planning
1. **ğŸ“š Project Context Refresh**
   - Read ALL documentation in `/docs/` directory to understand current product vision
   - Review `tasks.yaml` for current task status and dependencies
   - Analyze codebase structure using `@Codebase` to understand implementation state
   - Check git status for recent changes and commit history

2. **ğŸ¯ Task Prioritization & Selection**
   - Find the highest priority incomplete task in `tasks.yaml`
   - If current task is `in_progress`, continue with that task
   - If current task is `completed`, select next task based on:
     - Critical priority (1) tasks first
     - Dependency requirements (check `dependencies` array)
     - Development phase alignment (foundation â†’ frontend â†’ backend â†’ AI â†’ deployment)

3. **ğŸ§  Strategic Planning**
   - Analyze task requirements against existing codebase
   - Identify potential blockers or dependencies
   - Plan implementation approach using task's `cursor_hints`
   - Estimate realistic completion timeline

### Phase 2: Implementation Excellence
4. **ğŸš€ Smart Implementation**
   - Update task status to `in_progress` in `tasks.yaml`
   - Follow the **Golden Stack** technologies: Next.js 14+, HeroUI, Tailwind CSS, tRPC, Drizzle ORM, Clerk
   - Implement features using our **Glassmorphism Design System**:
     - Colors: Soft lavender (#f4f3ff), warm cream (#faf9f7), translucent glass surfaces
     - Typography: Clean sans-serif (Inter/SF Pro Display style) with 1.4-1.6 line heights
     - Layout: Dual-pane interface with generous rounded corners
     - Effects: Backdrop blur, subtle shadows, professional warmth
   - Write TypeScript with strict type safety
   - Use `@Files` and `@Docs` for implementation guidance

5. **ğŸ“ Documentation & Testing**
   - Update task `notes` field with implementation details
   - Create/update relevant tests for new features
   - Document any environment variables in task's `environment_variables`
   - Add terminal commands used to task's `terminal_commands`

### Phase 3: Quality Assurance & Iteration
6. **ğŸ” Quality Check**
   - Run linting and type checking (`npm run lint`, `npm run type-check`)
   - Test functionality manually if applicable
   - Verify responsive design and glassmorphism theming
   - Check integration with existing features

7. **âœ… Task Completion & Handoff**
   - Mark task status as `completed` in `tasks.yaml`
   - Update `actual_hours` based on time spent
   - Add completion date and any final notes
   - Create follow-up tasks if needed using `task_template`

### Phase 4: Continuous Improvement
8. **ğŸ”„ Loop Preparation**
   - Commit changes with descriptive commit messages
   - Update project documentation if architecture changed
   - Review blockers and dependencies for next iteration
   - **IMMEDIATELY start next loop iteration**

## ğŸ¨ Design System Requirements (Always Follow)

### Glassmorphism Theme Implementation
- **Primary Colors**: `#f4f3ff` (soft lavender), `#ffffff` (white), `#faf9f7` (warm cream)
- **Accent Colors**: `#ff6b6b` (coral), `#4ecdc4` (blue), `#ffd93d` (amber), `#a8e6cf` (sage)
- **Typography**: Inter or SF Pro Display, 1.4-1.6 line heights, generous letter spacing
- **Glass Effects**: `backdrop-blur-md`, `bg-opacity-20`, `border-white/20`
- **Shadows**: `shadow-lg shadow-black/10`

### Dual-Pane Interface Architecture
- **Left Panel**: Navigation with time-based grouping, conversation history cards
- **Right Panel**: Content workspace with mixed media integration
- **Responsive**: Tablet-optimized with touch-first design
- **Components**: Card-based content with rounded corners and glass effects

## ğŸ› ï¸ Technical Standards (Non-Negotiable)

### Code Quality Requirements
- **TypeScript**: Strict mode enabled, no `any` types
- **React**: Modern hooks, functional components, proper error boundaries
- **Performance**: Lazy loading, code splitting, React.memo for expensive components
- **Accessibility**: WCAG 2.1 AA compliance, proper ARIA labels
- **Testing**: Unit tests for utilities, integration tests for API endpoints

### Technology Stack Adherence
- **Frontend**: Next.js 14+ App Router, HeroUI components, Tailwind CSS
- **Backend**: tRPC for type-safe APIs, Drizzle ORM with PostgreSQL
- **Authentication**: Clerk with enterprise-grade security
- **AI**: Mirascope + Langflow integration for intelligent workflows
- **Deployment**: Vercel with edge computing optimization

## ğŸ“Š Task Management Intelligence

### Task Status Automation
- **Status Tracking**: Always update `tasks.yaml` with current task status
- **Dependency Management**: Never start tasks with incomplete dependencies
- **Progress Logging**: Update `actual_hours` and `notes` fields continuously
- **Blocker Identification**: Mark tasks as `blocked` if dependencies are missing

### Smart Task Creation
- **Use Template**: Follow `task_template` structure for consistency
- **Include Context**: Add `cursor_hints` for future AI assistance
- **Set Dependencies**: Properly link tasks with `dependencies` array
- **Define Success**: Clear `acceptance_criteria` for completion validation

## ğŸš¨ Error Handling & Recovery

### When Errors Occur
1. **Immediate**: Update task notes with error details
2. **Analyze**: Determine if error is blocker or solvable
3. **Research**: Use `@Web` for troubleshooting solutions
4. **Escalate**: Mark task as `blocked` if unable to resolve
5. **Document**: Add error resolution steps to task notes

### Recovery Strategies
- **Rollback**: Revert to last working state if necessary
- **Alternative**: Implement different approach if current path fails
- **Consultation**: Reference documentation and community resources
- **Iteration**: Adjust approach based on learnings

## ğŸ¯ Success Metrics & Validation

### Task Completion Criteria
- âœ… All acceptance criteria met
- âœ… Code passes linting and type checking
- âœ… Tests written and passing
- âœ… Documentation updated
- âœ… Design system compliance verified

### Continuous Monitoring
- **Performance**: Monitor build times and bundle sizes
- **Quality**: Track test coverage and code quality metrics
- **Progress**: Measure tasks completed vs. planned timeline
- **Blockers**: Identify and address dependency bottlenecks

## ğŸ”„ Loop Execution Commands

### Quick Reference Commands
```bash
# Start development loop
npm run dev

# Type checking
npm run type-check

# Linting
npm run lint

# Database operations
npx drizzle-kit generate
npx drizzle-kit migrate

# Testing
npm run test
npm run test:watch

# Build verification
npm run build
```

### Environment Setup Validation
- âœ… All environment variables configured
- âœ… Database connection established
- âœ… Authentication provider connected
- âœ… AI services integrated
- âœ… Development server running

## ğŸª Special Instructions for AI Agents

### Context Utilization
- **@Codebase**: Understand existing code structure before implementing
- **@Files**: Reference specific files for implementation patterns
- **@Docs**: Use HeroUI, tRPC, and Drizzle documentation
- **@Web**: Research latest best practices and troubleshooting

### Communication Style
- **Proactive**: Anticipate needs and suggest improvements
- **Detailed**: Provide comprehensive explanations for complex changes
- **Collaborative**: Ask clarifying questions when requirements are ambiguous
- **Solution-Oriented**: Focus on delivering working solutions

### Autonomy Guidelines
- **Self-Directed**: Continue loop execution without waiting for permission
- **Intelligent**: Make smart decisions based on project context
- **Transparent**: Document all decisions and reasoning
- **Adaptive**: Adjust approach based on feedback and results

---

## ğŸ­ The Continuous Loop Promise

This system ensures that development never stops, quality never compromises, and every iteration moves us closer to our vision of the premier AI-powered SMB platform. Each loop cycle builds upon the last, creating momentum that transforms individual tasks into a cohesive, world-class product.

**Loop Status**: ğŸ”„ ACTIVE - Ready for next iteration
**Current Phase**: Context Assessment & Planning
**Next Action**: Review tasks.yaml and select highest priority task

*Execute this loop continuously until the complete vision is realized.*